import {ChangeEventHandler, useCallback, useEffect, useMemo, useState} from "react"

import {DatabasesQueryResponse} from "@notionhq/client/build/src/api-endpoints"
import {Box, Flex} from "components/atoms"
import {SearchSection} from "components/organisms/global/SearchSection"
import {MusicAlbumCardDisplay} from "components/organisms/music/MusicAlbumCardDisplay"
import {TEMPLATE_A_TOP_BAR_MD_HEIGHT, TEMPLATE_A_TOP_BAR_SM_HEIGHT,TemplateA} from "components/templates/TemplateA"
import Fuse from "fuse.js"
import Head from "next/head"
import {zIndex} from "theme"
import {getMusicAlbumRatingOrder, MusicAlbumData, MusicAlbumRating, MusicAlbumTag,notion, notionFileUrlPrefix} from "utils/notion"
import {useDebouncedEffect} from "utils/optimization"


export type MusicProps = {
  database: DatabasesQueryResponse | null;
}

const getSrc = (key: string | undefined, notionFileUrlPrefix: string, tagList: MusicAlbumTag[]) => {
  if (tagList?.includes(MusicAlbumTag.BLOCKED_COVER)){
    return `${notionFileUrlPrefix}/music-album-covers/blocked.jpg` 
  }
  else {
    return key ? `${notionFileUrlPrefix}/music-album-covers/${key}.jpg` : undefined
  }
}

export const refineAlbumData = (item: MusicAlbumData) => {

  const artistList = (item.properties.Artist?.multi_select || []).map(item=>item.name) as string[]; 

  const rating = item.properties.Rating?.select.name as MusicAlbumRating;

  const releasedString = item.properties.Released?.date.start; // "1990-7-10"
  const released = releasedString ? Date.parse(releasedString) : undefined

  const rym = item.properties.RYM?.url;

  const reviewKor = item.properties["Review KOR"]?.rich_text[0]?.plain_text;
  const reviewEng = item.properties["Review ENG"]?.rich_text[0]?.plain_text;
  const reviewJpn = item.properties["Review JPN"]?.rich_text[0]?.plain_text;

  const tagList = (item.properties.Tags?.multi_select || []).map(item=>item.name) as MusicAlbumTag[]; 
  const title = item.properties.Title?.title[0].plain_text;

  const key = item.properties.Key?.rich_text[0]?.plain_text;

  const src = getSrc(key, notionFileUrlPrefix, tagList);

  const performer = item.properties.Key?.rich_text[0]?.plain_text;

  return ({
    ...item,
    essence: {
      artistList,
      rating,
      released,
      rym,
      tagList,
      title,
      key,
      src,
      performer,
      reviewKor,
      reviewEng,
      reviewJpn,
    }
  })
}

const FUSE_OPTIONS = {
  keys: [
    {
      name: "essence.title",
      weight: 12,
    },
    {
      name: "essence.artistList",
      weight: 8,
    },
    {
      name: "essence.rating",
      weight: 4,
    },
    {
      name: "essence.released",
      weight: 4,
    },
    "essence.tagList",
    "essence.performer",
    "essence.reviewKor",
    "essence.reviewEng",
    "essence.reviewJpn",
  ]
}

export const SEARCH_BAR_CONTAINER_HEIGHT = ["64px", "72px", "90px", "90px"]

export default function Music({
  database,
}:MusicProps) {

  const [searchValue, setSearchValue] = useState("");
  const [albumDataList, setAlbumDataList] = useState<MusicAlbumData[]>([])
  
  const updateAlbumDataList = useCallback(()=>{ 
    console.log("triggered")

    const existingAlbumDataList = database?.results.filter((item: MusicAlbumData) => {
      const title = item.properties.Title?.title[0]?.plain_text;
      return title ? true : false
    })

    const refinedAlbumDataList: MusicAlbumData[] = (existingAlbumDataList || []).map(refineAlbumData)

    const fuse = new Fuse(refinedAlbumDataList, FUSE_OPTIONS) 

    const filteredAlbumDataList = !searchValue 
      ? refinedAlbumDataList
      : fuse.search(searchValue).map(item => item.item)

    const sortedAlbumDataList = filteredAlbumDataList.sort((a, b)=>{
      if (a.essence?.rating && b.essence?.rating){
        return (getMusicAlbumRatingOrder(b.essence.rating) - getMusicAlbumRatingOrder(a.essence.rating))
      }
      else { 
        return 0 
      }
    });

    setAlbumDataList(sortedAlbumDataList)
  }, [database?.results, searchValue]);

  
  const onChangeSearch: ChangeEventHandler<HTMLInputElement> = useCallback((event)=>{
    setSearchValue(event.currentTarget.value)
  },[])

  useDebouncedEffect(()=>{
    console.log("try")
    updateAlbumDataList()
  }, [searchValue], 300)

  return (
    <TemplateA>
      <Head>
        <title>Music</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <Flex>

        <Flex sx={{
          position: "fixed", 
          top: [TEMPLATE_A_TOP_BAR_SM_HEIGHT, TEMPLATE_A_TOP_BAR_MD_HEIGHT, 0, 0], 
          height: SEARCH_BAR_CONTAINER_HEIGHT,
          zIndex: zIndex.searchBar,
        }}>
          <SearchSection value={searchValue} onChange={onChangeSearch}/>
        </Flex>

        <Flex>
          <MusicAlbumCardDisplay albumDataList={albumDataList}></MusicAlbumCardDisplay>
        </Flex>
        
      </Flex>
    </TemplateA>
  )
}

export async function getServerSideProps() {
   
  try { 
    const database = await notion.databases.query({database_id: process.env.NEXT_PUBLIC_NOTION_MUSIC_DB_ID || ""});
    return {props: { 
      database,
    }}
  }
  catch {
    return {props: { 
      database: null, 
    }}
  }
}